<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neo4j 실시간 모니터링 대시보드</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
            color: #fff;
            overflow: hidden;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            text-align: center;
            border-bottom: 2px solid #00ff88;
        }

        h1 {
            font-size: 28px;
            font-weight: 300;
            letter-spacing: 2px;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #00ff88;
            margin-right: 10px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.1); }
        }

        .container {
            display: flex;
            height: calc(100vh - 80px);
        }

        .sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #333;
        }

        .stat-card {
            background: rgba(45, 45, 45, 0.8);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 15px;
            /* border-left: 4px solid #00ff88; */
            transition: transform 0.2s;
        }

        .stat-card:hover {
            transform: translateX(5px);
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .label-list {
            margin-top: 20px;
        }

        .label-item {
            background: rgba(45, 45, 45, 0.6);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            font-size: 14px;
        }

        .label-name {
            color: #00ff88;
        }

        .label-count {
            color: #888;
        }

        .main-content {
            flex: 1;
            position: relative;
        }

        #graph {
            width: 100%;
            height: 100%;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s;
            stroke: rgba(255, 255, 255, 0.3);
            stroke-width: 2px;
        }

        .node:hover {
            stroke: #fff;
            stroke-width: 4px;
            filter: brightness(1.3);
        }

        .link {
            stroke: #666;
            stroke-opacity: 0.4;
            stroke-width: 2px;
        }

        .link-label {
            font-size: 11px;
            fill: #aaa;
            text-anchor: middle;
            pointer-events: none;
            font-weight: 500;
        }

        .node-label {
            font-size: 12px;
            fill: #fff;
            text-anchor: middle;
            pointer-events: none;
            font-weight: 600;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
        }

        .update-time {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 12px;
            color: #888;
        }

        .update-status {
            display: inline-block;
            margin-left: 10px;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
        }

        .status-changed {
            background: #00ff88;
            color: #000;
        }

        .status-unchanged {
            background: #666;
            color: #fff;
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            max-width: 400px;
        }

        .control-button {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            font-size: 13px;
        }

        .control-button:hover {
            background: #00cc6a;
            transform: translateY(-2px);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #00ff88;
        }

        /* 화살표 마커 스타일 */
        .arrow {
            fill: #666;
            opacity: 0.6;
        }

        /* 노드 상세정보 패널 */
        .node-detail-panel {
            position: absolute;
            right: 20px;
            top: 120px;
            width: 350px;
            max-height: calc(100vh - 200px);
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 20px;
            overflow-y: auto;
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 255, 136, 0.3);
        }

        .node-detail-panel.active {
            transform: translateX(0);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #333;
        }

        .panel-title {
            font-size: 20px;
            font-weight: bold;
            color: #00ff88;
        }

        .close-button {
            background: transparent;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .close-button:hover {
            color: #ff6b6b;
            transform: rotate(90deg);
        }

        .detail-section {
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 14px;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .detail-item {
            background: rgba(45, 45, 45, 0.6);
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 5px;
            /* border-left: 3px solid #00ff88; */
        }

        .detail-key {
            color: #aaa;
            font-size: 12px;
            margin-bottom: 4px;
        }

        .detail-value {
            color: #fff;
            font-size: 14px;
            word-break: break-all;
            font-weight: 500;
        }

        .label-badge {
            display: inline-block;
            background: #00ff88;
            color: #000;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        .no-properties {
            color: #666;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }

        .node-id-badge {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #888;
            margin-top: 10px;
        }

        /* 스크롤바 스타일 */
        .node-detail-panel::-webkit-scrollbar {
            width: 8px;
        }

        .node-detail-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .node-detail-panel::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 10px;
        }

        .node-detail-panel::-webkit-scrollbar-thumb:hover {
            background: #00cc6a;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1><span class="status-indicator"></span>Neo4j 실시간 모니터링 대시보드</h1>
    </div>

    <div class="container">
        <div class="sidebar">
            <div class="stat-card">
                <div class="stat-value" id="nodeCount">0</div>
                <div class="stat-label">전체 노드</div>
            </div>

            <div class="stat-card">
                <div class="stat-value" id="relCount">0</div>
                <div class="stat-label">전체 관계</div>
            </div>

            <div class="stat-card">
                <div class="stat-value" id="labelCount">0</div>
                <div class="stat-label">노드 타입</div>
            </div>

            <div class="label-list">
                <h3 style="margin-bottom: 15px; color: #00ff88;">타입별 분포</h3>
                <div id="labelList"></div>
            </div>
        </div>

        <div class="main-content">
            <div class="controls">
                <button class="control-button" onclick="toggleAutoRefresh()">
                    <span id="refreshStatus">일시정지</span>
                </button>
                <button class="control-button" onclick="fetchData()">지금 새로고침</button>
                <button class="control-button" onclick="zoomIn()">확대 +</button>
                <button class="control-button" onclick="zoomOut()">축소 -</button>
                <button class="control-button" onclick="resetZoom()">줌 리셋</button>
                <button class="control-button" onclick="toggleLabels()">라벨 토글</button>
            </div>

            <!-- 노드 상세정보 패널 -->
            <div id="nodeDetailPanel" class="node-detail-panel">
                <div class="panel-header">
                    <div class="panel-title">노드 상세정보</div>
                    <button class="close-button" onclick="closeNodeDetail()">×</button>
                </div>
                <div id="nodeDetailContent"></div>
            </div>
            
            <svg id="graph"></svg>
            
            <div class="update-time">
                마지막 업데이트: <span id="updateTime">-</span>
                <span id="updateStatus" class="update-status"></span>
            </div>

            <div class="loading" id="loading">데이터 로딩 중...</div>
        </div>
    </div>

    <script>
        let autoRefresh = true;
        let refreshInterval;
        let previousData = null;
        let showLabels = true;

        const width = window.innerWidth - 300;
        const height = window.innerHeight - 80;

        const svg = d3.select("#graph")
            .attr("width", width)
            .attr("height", height);

        // 화살표 마커 정의
        svg.append("defs").selectAll("marker")
            .data(["arrow"])
            .enter().append("marker")
            .attr("id", d => d)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 25)
            .attr("refY", 0)
            .attr("markerWidth", 8)
            .attr("markerHeight", 8)
            .attr("orient", "auto")
            .append("path")
            .attr("class", "arrow")
            .attr("d", "M0,-5L10,0L0,5");

        // 줌/팬을 위한 g 그룹 추가
        const g = svg.append("g");

        // 줌 동작 설정
        const zoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });

        svg.call(zoom);

        // 시뮬레이션 설정 - 간격을 훨씬 넓게!
        const simulation = d3.forceSimulation()
            .alphaDecay(0.08)  // 기본값 0.0228보다 낮춰서 천천히 안정화
            .velocityDecay(0.4)  // 기본값 0.4보다 높여서 빠르게 감속 (떨림 방지)
            .force("link", d3.forceLink().id(d => d.id)
                .distance(100)  // 100 -> 200으로 증가
                .strength(0.8))  // 0.5 -> 0.3으로 줄여서 링크 강도 약화
            .force("charge", d3.forceManyBody()
                .strength(-1200))  // -300 -> -800으로 더 강한 반발력
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide()
                .radius(60)  // 30 -> 60으로 충돌 반경 증가
                .strength(0.5))  // 충돌 강도 최대로 설정
            .force("x", d3.forceX(width / 2).strength(0.05))  // X축 중력
            .force("y", d3.forceY(height / 2).strength(0.05)); // Y축 중력

        let linkElements, nodeElements, textElements, linkLabelElements;

        async function fetchStats() {
            try {
                const response = await fetch('http://localhost:3000/api/stats');
                const data = await response.json();

                document.getElementById('nodeCount').textContent = data.nodes.toLocaleString();
                document.getElementById('relCount').textContent = data.relationships.toLocaleString();
                document.getElementById('labelCount').textContent = data.labelCounts.length;

                const labelList = document.getElementById('labelList');
                labelList.innerHTML = data.labelCounts.map(item => `
                    <div class="label-item">
                        <span class="label-name">${item.label || 'Unknown'}</span>
                        <span class="label-count">${item.count.toLocaleString()}</span>
                    </div>
                `).join('');

            } catch (error) {
                console.error('통계 가져오기 실패:', error);
            }
        }

        async function fetchGraph() {
            try {
                const response = await fetch('http://localhost:3000/api/graph');
                const data = await response.json();

                const statusEl = document.getElementById('updateStatus');
                
                if (hasDataChanged(data)) {
                    console.log('✅ 데이터 변경 감지 - 그래프 업데이트');
                    updateGraph(data);
                    previousData = JSON.parse(JSON.stringify(data));
                    
                    statusEl.textContent = '변경됨';
                    statusEl.className = 'update-status status-changed';
                } else {
                    console.log('⏸️  변경사항 없음 - 그래프 유지');
                    
                    statusEl.textContent = '변경없음';
                    statusEl.className = 'update-status status-unchanged';
                }
                
                document.getElementById('updateTime').textContent = 
                    new Date().toLocaleTimeString('ko-KR');
                document.getElementById('loading').style.display = 'none';

            } catch (error) {
                console.error('그래프 가져오기 실패:', error);
                document.getElementById('loading').textContent = '연결 실패';
            }
        }

        function hasDataChanged(newData) {
            if (!previousData) return true;

            if (newData.nodes.length !== previousData.nodes.length) return true;
            if (newData.relationships.length !== previousData.relationships.length) return true;

            const newNodeIds = new Set(newData.nodes.map(n => n.id));
            const oldNodeIds = new Set(previousData.nodes.map(n => n.id));
            
            if (newNodeIds.size !== oldNodeIds.size) return true;
            
            for (let id of newNodeIds) {
                if (!oldNodeIds.has(id)) return true;
            }

            const newRelIds = new Set(
                newData.relationships.map(r => `${r.source}-${r.target}-${r.type}`)
            );
            const oldRelIds = new Set(
                previousData.relationships.map(r => `${r.source}-${r.target}-${r.type}`)
            );

            if (newRelIds.size !== oldRelIds.size) return true;

            for (let id of newRelIds) {
                if (!oldRelIds.has(id)) return true;
            }

            return false;
        }

        function updateGraph(data) {
            g.selectAll("*").remove();

            if (data.nodes.length === 0) {
                g.append("text")
                    .attr("x", width / 2)
                    .attr("y", height / 2)
                    .attr("text-anchor", "middle")
                    .style("fill", "#666")
                    .style("font-size", "18px")
                    .text("데이터가 없습니다");
                return;
            }

            const links = data.relationships.map(d => ({...d}));
            const nodes = data.nodes.map(d => ({...d}));

            // 링크 그리기 (화살표 포함)
            linkElements = g.append("g")
                .selectAll("line")
                .data(links)
                .enter().append("line")
                .attr("class", "link")
                .attr("marker-end", "url(#arrow)");

            // 링크 라벨 추가 (관계 타입 표시)
            linkLabelElements = g.append("g")
                .selectAll("text")
                .data(links)
                .enter().append("text")
                .attr("class", "link-label")
                .text(d => d.type)
                .style("display", showLabels ? "block" : "none");

            // 노드 그리기 (크기 증가)
            nodeElements = g.append("g")
                .selectAll("circle")
                .data(nodes)
                .enter().append("circle")
                .attr("class", "node")
                .attr("r", 20)  // 15 -> 20으로 증가
                .attr("fill", d => getNodeColor(d.labels[0]))
                .on("click", (event, d) => {
                    event.stopPropagation();
                    showNodeDetail(d);
                })
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            // 노드 라벨
            textElements = g.append("g")
                .selectAll("text")
                .data(nodes)
                .enter().append("text")
                .attr("class", "node-label")
                .attr("dy", 35)  // 노드 아래에 표시
                .text(d => d.labels[0] || 'Node')
                .style("display", showLabels ? "block" : "none");

            // 툴팁 추가
            nodeElements.append("title")
                .text(d => {
                    const props = Object.entries(d.properties || {})
                        .map(([k, v]) => `${k}: ${v}`)
                        .join('\n');
                    return `${d.labels[0]}\nID: ${d.id}\n${props}`;
                });

            simulation.nodes(nodes).on("tick", ticked);
            simulation.force("link").links(links);
            simulation.alpha(1).restart();
        }

        function ticked() {
            linkElements
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            linkLabelElements
                .attr("x", d => (d.source.x + d.target.x) / 2)
                .attr("y", d => (d.source.y + d.target.y) / 2);

            nodeElements
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);

            textElements
                .attr("x", d => d.x)
                .attr("y", d => d.y);
        }

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        function getNodeColor(label) {
            const colors = {
                'Person': '#00ff88',
                'Company': '#ff6b6b',
                'Product': '#4ecdc4',
                'Location': '#ffe66d',
                'Event': '#a8dadc',
                'Organization': '#f38181',
                'Technology': '#aa96da',
                'Document': '#fcbad3'
            };
            return colors[label] || '#95e1d3';
        }

        function toggleAutoRefresh() {
            autoRefresh = !autoRefresh;
            document.getElementById('refreshStatus').textContent = 
                autoRefresh ? '일시정지' : '재개';
            
            if (autoRefresh) {
                startAutoRefresh();
            } else {
                clearInterval(refreshInterval);
            }
        }

        function toggleLabels() {
            showLabels = !showLabels;
            if (textElements) {
                textElements.style("display", showLabels ? "block" : "none");
            }
            if (linkLabelElements) {
                linkLabelElements.style("display", showLabels ? "block" : "none");
            }
        }

        function zoomIn() {
            svg.transition().call(zoom.scaleBy, 1.3);
        }

        function zoomOut() {
            svg.transition().call(zoom.scaleBy, 0.7);
        }

        function resetZoom() {
            svg.transition().call(
                zoom.transform,
                d3.zoomIdentity.translate(0, 0).scale(1)
            );
        }

        function startAutoRefresh() {
            refreshInterval = setInterval(() => {
                if (autoRefresh) {
                    fetchData();
                }
            }, 3000);
        }

        async function fetchData() {
            await Promise.all([fetchStats(), fetchGraph()]);
        }

        // 노드 상세정보 표시 함수
        function showNodeDetail(node) {
            const panel = document.getElementById('nodeDetailPanel');
            const content = document.getElementById('nodeDetailContent');
            
            // 라벨 뱃지들
            const labelBadges = node.labels
                .map(label => `<span class="label-badge">${label}</span>`)
                .join('');
            
            // 속성들
            const properties = Object.entries(node.properties || {});
            const propertiesHTML = properties.length > 0
                ? properties.map(([key, value]) => `
                    <div class="detail-item">
                        <div class="detail-key">${key}</div>
                        <div class="detail-value">${formatValue(value)}</div>
                    </div>
                `).join('')
                : '<div class="no-properties">속성이 없습니다</div>';
            
            content.innerHTML = `
                <div class="detail-section">
                    <div class="section-title">노드 타입</div>
                    ${labelBadges}
                </div>
                
                <div class="detail-section">
                    <div class="section-title">속성</div>
                    ${propertiesHTML}
                </div>
                
                <div class="node-id-badge">
                    노드 ID: ${node.id}
                </div>
            `;
            
            panel.classList.add('active');
        }
        
        // 노드 상세정보 패널 닫기
        function closeNodeDetail() {
            const panel = document.getElementById('nodeDetailPanel');
            panel.classList.remove('active');
        }
        
        // 값 포맷팅 함수
        function formatValue(value) {
            if (value === null || value === undefined) {
                return '<span style="color: #666;">null</span>';
            }
            if (typeof value === 'boolean') {
                return value ? '<span style="color: #00ff88;">true</span>' : '<span style="color: #ff6b6b;">false</span>';
            }
            if (typeof value === 'object') {
                return `<pre style="margin: 0; color: #888;">${JSON.stringify(value, null, 2)}</pre>`;
            }
            if (typeof value === 'number') {
                return `<span style="color: #4ecdc4;">${value.toLocaleString()}</span>`;
            }
            return String(value);
        }
        
        // 배경 클릭 시 패널 닫기
        svg.on("click", () => {
            closeNodeDetail();
        });

        // 초기 로드
        fetchData();
        startAutoRefresh();
    </script>
</body>
</html>
